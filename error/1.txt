1. Error in event handler: TypeError: Cannot read properties of undefined (reading 'create') at CognitoTableBackground.showWelcomeNotification (chrome-extension://nfkmjeochepmnmihbmgodjmickbeapno/background.js:79:30) at chrome-extension://nfkmjeochepmnmihbmgodjmickbeapno/background.js:18:22
Context
Unknown
Stack Trace

2. Error scanning page: Error: Cannot access a chrome:// URL
Context
popup.html
Stack Trace
popup.js:35 (scanCurrentPage)

class CognitoTablePopup {
    constructor() {
        this.detectedTables = [];
        this.currentTable = null;
        this.init();
    }

    async init() {
        await this.setupEventListeners();
        await this.scanCurrentPage();
    }

    setupEventListeners() {
        document.getElementById('deepScan').addEventListener('click', () => this.performDeepScan());
        document.getElementById('manualSelect').addEventListener('click', () => this.activateManualSelection());
        document.getElementById('multiPage').addEventListener('click', () => this.startMultiPageExtraction());
        document.getElementById('backBtn').addEventListener('click', () => this.showMainView());
        document.getElementById('exportCsv').addEventListener('click', () => this.exportData('csv'));
        document.getElementById('exportJson').addEventListener('click', () => this.exportData('json'));
    }

    async scanCurrentPage() {
        try {
            const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
            
            const results = await chrome.scripting.executeScript({
                target: { tabId: tab.id },
                func: this.scanPageForTables
            });

            const tables = results[0].result;
            this.detectedTables = tables;
            this.updateUI();
        } catch (error) {
            console.error('Error scanning page:', error);
            this.showError('Failed to scan page for tables');
        }
    }

    scanPageForTables() {
        const tables = [];
        let tableId = 0;

        const explicitTables = document.querySelectorAll('table');
        explicitTables.forEach(table => {
            const tableData = this.extractTableData(table, 'explicit');
            if (tableData.rows.length > 0) {
                tables.push({
                    id: ++tableId,
                    type: 'explicit',
                    confidence: 0.95,
                    element: this.getElementSelector(table),
                    data: tableData,
                    preview: this.generatePreview(tableData)
                });
            }
        });

        const implicitTables = this.findImplicitTables();
        implicitTables.forEach(table => {
            const tableData = this.extractTableData(table.element, 'implicit');
            if (tableData.rows.length > 1) {
                tables.push({
                    id: ++tableId,
                    type: 'implicit',
                    confidence: table.confidence,
                    element: this.getElementSelector(table.element),
                    data: tableData,
                    preview: this.generatePreview(tableData)
                });
            }
        });

        return tables;
    }

    findImplicitTables() {
        const candidates = [];
        const containers = document.querySelectorAll('div, ul, ol, section, article');
        
        containers.forEach(container => {
            const children = Array.from(container.children);
            if (children.length < 2) return;

            const structuralSimilarity = this.calculateStructuralSimilarity(children);
            if (structuralSimilarity > 0.7) {
                const visualAlignment = this.assessVisualAlignment(children);
                const confidence = (structuralSimilarity + visualAlignment) / 2;
                
                if (confidence > 0.6) {
                    candidates.push({
                        element: container,
                        confidence: confidence,
                        children: children
                    });
                }
            }
        });

        return candidates.sort((a, b) => b.confidence - a.confidence).slice(0, 5);
    }

    calculateStructuralSimilarity(elements) {
        if (elements.length < 2) return 0;

        const signatures = elements.map(el => this.getStructuralSignature(el));
        const uniqueSignatures = new Set(signatures);
        
        return 1 - (uniqueSignatures.size - 1) / (signatures.length - 1);
    }

    getStructuralSignature(element) {
        const tagName = element.tagName.toLowerCase();
        const childCount = element.children.length;
        const classNames = Array.from(element.classList).sort().join(' ');
        const hasText = element.textContent.trim().length > 0;
        
        return `${tagName}:${childCount}:${classNames}:${hasText}`;
    }

    assessVisualAlignment(elements) {
        const rects = elements.map(el => el.getBoundingClientRect());
        
        const leftAlignment = this.calculateAlignment(rects.map(r => r.left));
        const widthConsistency = this.calculateAlignment(rects.map(r => r.width));
        const heightConsistency = this.calculateAlignment(rects.map(r => r.height));
        
        return (leftAlignment + widthConsistency + heightConsistency) / 3;
    }

    calculateAlignment(values) {
        if (values.length < 2) return 1;
        
        const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
        const variance = values.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / values.length;
        const stdDev = Math.sqrt(variance);
        
        return Math.max(0, 1 - (stdDev / avg));
    }

    extractTableData(element, type) {
        const data = { headers: [], rows: [], columnTypes: [] };

        if (type === 'explicit' && element.tagName.toLowerCase() === 'table') {
            return this.extractExplicitTableData(element);
        } else {
            return this.extractImplicitTableData(element);
        }
    }

    extractExplicitTableData(table) {
        const data = { headers: [], rows: [], columnTypes: [] };
        const headerRow = table.querySelector('thead tr, tr:first-child');
        const bodyRows = table.querySelectorAll('tbody tr, tr:not(:first-child)');

        if (headerRow) {
            const headers = Array.from(headerRow.querySelectorAll('th, td')).map(cell => 
                cell.textContent.trim()
            );
            data.headers = headers;
        }

        bodyRows.forEach(row => {
            const cells = Array.from(row.querySelectorAll('td, th')).map(cell => 
                cell.textContent.trim()
            );
            if (cells.some(cell => cell.length > 0)) {
                data.rows.push(cells);
            }
        });

        data.columnTypes = this.inferColumnTypes(data.rows);
        return data;
    }

    extractImplicitTableData(container) {
        const data = { headers: [], rows: [], columnTypes: [] };
        const children = Array.from(container.children);

        children.forEach((child, index) => {
            const cells = this.extractCellsFromElement(child);
            if (cells.length > 0) {
                if (index === 0 && this.looksLikeHeader(child)) {
                    data.headers = cells;
                } else {
                    data.rows.push(cells);
                }
            }
        });

        if (data.headers.length === 0 && data.rows.length > 0) {
            data.headers = data.rows[0].map((_, i) => `Column ${i + 1}`);
        }

        data.columnTypes = this.inferColumnTypes(data.rows);
        return data;
    }

    extractCellsFromElement(element) {
        const cells = [];
        const textNodes = this.getTextNodes(element);
        
        if (textNodes.length === 0) {
            const text = element.textContent.trim();
            if (text) cells.push(text);
        } else {
            textNodes.forEach(node => {
                const text = node.textContent.trim();
                if (text) cells.push(text);
            });
        }

        return cells;
    }

    getTextNodes(element) {
        const textNodes = [];
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        let node;
        while (node = walker.nextNode()) {
            if (node.textContent.trim()) {
                textNodes.push(node);
            }
        }

        return textNodes;
    }

    looksLikeHeader(element) {
        const style = window.getComputedStyle(element);
        const fontWeight = parseInt(style.fontWeight) || 400;
        const fontSize = parseFloat(style.fontSize) || 14;
        const backgroundColor = style.backgroundColor;
        
        return fontWeight >= 600 || fontSize > 16 || 
               backgroundColor !== 'rgba(0, 0, 0, 0)';
    }

    inferColumnTypes(rows) {
        if (rows.length === 0) return [];
        
        const columnCount = Math.max(...rows.map(row => row.length));
        const types = [];

        for (let col = 0; col < columnCount; col++) {
            const values = rows.map(row => row[col] || '').filter(val => val.length > 0);
            types.push(this.inferColumnType(values));
        }

        return types;
    }

    inferColumnType(values) {
        if (values.length === 0) return 'text';

        const patterns = {
            number: /^-?\d+(\.\d+)?$/,
            currency: /^[\$\€\£\¥]?\s?\d+([,\.]?\d+)*(\.\d{2})?$/,
            date: /^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$|^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
            email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            url: /^https?:\/\/.+/,
            phone: /^[\+]?[\d\s\-\(\)]+$/
        };

        for (const [type, pattern] of Object.entries(patterns)) {
            const matches = values.filter(val => pattern.test(val.trim())).length;
            if (matches / values.length > 0.7) {
                return type;
            }
        }

        return 'text';
    }

    generatePreview(tableData) {
        const maxRows = 3;
        const maxCols = 4;
        
        let preview = '';
        if (tableData.headers.length > 0) {
            preview += tableData.headers.slice(0, maxCols).join(' | ') + '\n';
            preview += '─'.repeat(Math.min(50, preview.length - 1)) + '\n';
        }
        
        tableData.rows.slice(0, maxRows).forEach(row => {
            preview += row.slice(0, maxCols).map(cell => 
                cell.length > 20 ? cell.substring(0, 17) + '...' : cell
            ).join(' | ') + '\n';
        });

        if (tableData.rows.length > maxRows) {
            preview += `... and ${tableData.rows.length - maxRows} more rows\n`;
        }

        return preview;
    }

    getElementSelector(element) {
        if (element.id) return `#${element.id}`;
        
        const path = [];
        while (element && element.nodeType === Node.ELEMENT_NODE) {
            let selector = element.nodeName.toLowerCase();
            if (element.className) {
                selector += '.' + element.className.trim().split(/\s+/).join('.');
            }
            path.unshift(selector);
            element = element.parentNode;
            if (path.length > 5) break;
        }
        
        return path.join(' > ');
    }

    updateUI() {
        document.getElementById('status').style.display = 'none';
        document.getElementById('content').style.display = 'block';
        document.getElementById('tableCount').textContent = this.detectedTables.length;

        const tableList = document.getElementById('tableList');
        tableList.innerHTML = '';

        if (this.detectedTables.length === 0) {
            tableList.innerHTML = `
                <div class="no-tables">
                    <h4>No tables detected</h4>
                    <p>Try using "Deep Scan" or "Manual Selection" to find hidden tabular data.</p>
                </div>
            `;
            return;
        }

        this.detectedTables.forEach(table => {
            const item = this.createTableItem(table);
            tableList.appendChild(item);
        });
    }

    createTableItem(table) {
        const item = document.createElement('div');
        item.className = 'table-item';
        item.dataset.tableId = table.id;

        const confidenceClass = table.confidence >= 0.8 ? 'high' : 
                               table.confidence >= 0.6 ? 'medium' : 'low';

        item.innerHTML = `
            <div class="table-info">
                <span class="table-title">${table.type === 'explicit' ? 'HTML Table' : 'Implicit Table'} #${table.id}</span>
                <span class="confidence-score ${confidenceClass}">${Math.round(table.confidence * 100)}%</span>
            </div>
            <div class="table-preview-text">${table.preview}</div>
        `;

        item.addEventListener('click', () => this.viewTable(table));
        item.addEventListener('mouseenter', () => this.highlightTable(table));
        item.addEventListener('mouseleave', () => this.unhighlightTable(table));

        return item;
    }

    async highlightTable(table) {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        
        chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: (selector) => {
                const element = document.querySelector(selector);
                if (element) {
                    element.style.outline = '3px solid #667eea';
                    element.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                }
            },
            args: [table.element]
        });
    }

    async unhighlightTable(table) {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        
        chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: (selector) => {
                const element = document.querySelector(selector);
                if (element) {
                    element.style.outline = '';
                    element.style.backgroundColor = '';
                }
            },
            args: [table.element]
        });
    }

    viewTable(table) {
        this.currentTable = table;
        this.renderTablePreview(table);
        document.getElementById('content').style.display = 'none';
        document.getElementById('tablePreview').style.display = 'block';
    }

    renderTablePreview(table) {
        const container = document.getElementById('tableContainer');
        const tableElement = document.createElement('table');
        tableElement.className = 'preview-table';

        if (table.data.headers.length > 0) {
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            table.data.headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            tableElement.appendChild(thead);
        }

        const tbody = document.createElement('tbody');
        table.data.rows.forEach(row => {
            const tr = document.createElement('tr');
            row.forEach(cell => {
                const td = document.createElement('td');
                td.textContent = cell;
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });

        tableElement.appendChild(tbody);
        container.innerHTML = '';
        container.appendChild(tableElement);
    }

    showMainView() {
        document.getElementById('tablePreview').style.display = 'none';
        document.getElementById('content').style.display = 'block';
    }

    exportData(format) {
        if (!this.currentTable) return;

        const data = this.currentTable.data;
        let content = '';
        let filename = `table_${this.currentTable.id}.${format}`;

        if (format === 'csv') {
            content = this.convertToCSV(data);
        } else if (format === 'json') {
            content = this.convertToJSON(data);
        }

        this.downloadFile(content, filename);
    }

    convertToCSV(data) {
        const rows = [];
        
        if (data.headers.length > 0) {
            rows.push(data.headers.map(header => this.escapeCSV(header)).join(','));
        }
        
        data.rows.forEach(row => {
            rows.push(row.map(cell => this.escapeCSV(cell)).join(','));
        });

        return rows.join('\n');
    }

    escapeCSV(field) {
        if (field.includes(',') || field.includes('"') || field.includes('\n')) {
            return `"${field.replace(/"/g, '""')}"`;
        }
        return field;
    }

    convertToJSON(data) {
        const result = [];
        
        data.rows.forEach(row => {
            const obj = {};
            row.forEach((cell, index) => {
                const key = data.headers[index] || `column_${index + 1}`;
                obj[key] = cell;
            });
            result.push(obj);
        });

        return JSON.stringify(result, null, 2);
    }

    downloadFile(content, filename) {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async performDeepScan() {
        document.getElementById('status').style.display = 'block';
        document.getElementById('content').style.display = 'none';
        document.querySelector('#status span').textContent = 'Performing deep scan...';

        setTimeout(async () => {
            await this.scanCurrentPage();
        }, 1000);
    }

    activateManualSelection() {
        window.close();
    }

    startMultiPageExtraction() {
        alert('Multi-page extraction feature coming soon!');
    }

    showError(message) {
        document.getElementById('status').innerHTML = `
            <div style="color: #dc3545;">
                <strong>Error:</strong> ${message}
            </div>
        `;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CognitoTablePopup();
});

3. Error scanning page: TypeError: Cannot read properties of null (reading 'length')
Context
popup.html
Stack Trace

class CognitoTablePopup {
    constructor() {
        this.detectedTables = [];
        this.currentTable = null;
        this.init();
    }

    async init() {
        await this.setupEventListeners();
        await this.scanCurrentPage();
    }

    setupEventListeners() {
        document.getElementById('deepScan').addEventListener('click', () => this.performDeepScan());
        document.getElementById('manualSelect').addEventListener('click', () => this.activateManualSelection());
        document.getElementById('multiPage').addEventListener('click', () => this.startMultiPageExtraction());
        document.getElementById('backBtn').addEventListener('click', () => this.showMainView());
        document.getElementById('exportCsv').addEventListener('click', () => this.exportData('csv'));
        document.getElementById('exportJson').addEventListener('click', () => this.exportData('json'));
    }

    async scanCurrentPage() {
        try {
            const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
            
            const results = await chrome.scripting.executeScript({
                target: { tabId: tab.id },
                func: this.scanPageForTables
            });

            const tables = results[0].result;
            this.detectedTables = tables;
            this.updateUI();
        } catch (error) {
            console.error('Error scanning page:', error);
            this.showError('Failed to scan page for tables');
        }
    }

    scanPageForTables() {
        const tables = [];
        let tableId = 0;

        const explicitTables = document.querySelectorAll('table');
        explicitTables.forEach(table => {
            const tableData = this.extractTableData(table, 'explicit');
            if (tableData.rows.length > 0) {
                tables.push({
                    id: ++tableId,
                    type: 'explicit',
                    confidence: 0.95,
                    element: this.getElementSelector(table),
                    data: tableData,
                    preview: this.generatePreview(tableData)
                });
            }
        });

        const implicitTables = this.findImplicitTables();
        implicitTables.forEach(table => {
            const tableData = this.extractTableData(table.element, 'implicit');
            if (tableData.rows.length > 1) {
                tables.push({
                    id: ++tableId,
                    type: 'implicit',
                    confidence: table.confidence,
                    element: this.getElementSelector(table.element),
                    data: tableData,
                    preview: this.generatePreview(tableData)
                });
            }
        });

        return tables;
    }

    findImplicitTables() {
        const candidates = [];
        const containers = document.querySelectorAll('div, ul, ol, section, article');
        
        containers.forEach(container => {
            const children = Array.from(container.children);
            if (children.length < 2) return;

            const structuralSimilarity = this.calculateStructuralSimilarity(children);
            if (structuralSimilarity > 0.7) {
                const visualAlignment = this.assessVisualAlignment(children);
                const confidence = (structuralSimilarity + visualAlignment) / 2;
                
                if (confidence > 0.6) {
                    candidates.push({
                        element: container,
                        confidence: confidence,
                        children: children
                    });
                }
            }
        });

        return candidates.sort((a, b) => b.confidence - a.confidence).slice(0, 5);
    }

    calculateStructuralSimilarity(elements) {
        if (elements.length < 2) return 0;

        const signatures = elements.map(el => this.getStructuralSignature(el));
        const uniqueSignatures = new Set(signatures);
        
        return 1 - (uniqueSignatures.size - 1) / (signatures.length - 1);
    }

    getStructuralSignature(element) {
        const tagName = element.tagName.toLowerCase();
        const childCount = element.children.length;
        const classNames = Array.from(element.classList).sort().join(' ');
        const hasText = element.textContent.trim().length > 0;
        
        return `${tagName}:${childCount}:${classNames}:${hasText}`;
    }

    assessVisualAlignment(elements) {
        const rects = elements.map(el => el.getBoundingClientRect());
        
        const leftAlignment = this.calculateAlignment(rects.map(r => r.left));
        const widthConsistency = this.calculateAlignment(rects.map(r => r.width));
        const heightConsistency = this.calculateAlignment(rects.map(r => r.height));
        
        return (leftAlignment + widthConsistency + heightConsistency) / 3;
    }

    calculateAlignment(values) {
        if (values.length < 2) return 1;
        
        const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
        const variance = values.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / values.length;
        const stdDev = Math.sqrt(variance);
        
        return Math.max(0, 1 - (stdDev / avg));
    }

    extractTableData(element, type) {
        const data = { headers: [], rows: [], columnTypes: [] };

        if (type === 'explicit' && element.tagName.toLowerCase() === 'table') {
            return this.extractExplicitTableData(element);
        } else {
            return this.extractImplicitTableData(element);
        }
    }

    extractExplicitTableData(table) {
        const data = { headers: [], rows: [], columnTypes: [] };
        const headerRow = table.querySelector('thead tr, tr:first-child');
        const bodyRows = table.querySelectorAll('tbody tr, tr:not(:first-child)');

        if (headerRow) {
            const headers = Array.from(headerRow.querySelectorAll('th, td')).map(cell => 
                cell.textContent.trim()
            );
            data.headers = headers;
        }

        bodyRows.forEach(row => {
            const cells = Array.from(row.querySelectorAll('td, th')).map(cell => 
                cell.textContent.trim()
            );
            if (cells.some(cell => cell.length > 0)) {
                data.rows.push(cells);
            }
        });

        data.columnTypes = this.inferColumnTypes(data.rows);
        return data;
    }

    extractImplicitTableData(container) {
        const data = { headers: [], rows: [], columnTypes: [] };
        const children = Array.from(container.children);

        children.forEach((child, index) => {
            const cells = this.extractCellsFromElement(child);
            if (cells.length > 0) {
                if (index === 0 && this.looksLikeHeader(child)) {
                    data.headers = cells;
                } else {
                    data.rows.push(cells);
                }
            }
        });

        if (data.headers.length === 0 && data.rows.length > 0) {
            data.headers = data.rows[0].map((_, i) => `Column ${i + 1}`);
        }

        data.columnTypes = this.inferColumnTypes(data.rows);
        return data;
    }

    extractCellsFromElement(element) {
        const cells = [];
        const textNodes = this.getTextNodes(element);
        
        if (textNodes.length === 0) {
            const text = element.textContent.trim();
            if (text) cells.push(text);
        } else {
            textNodes.forEach(node => {
                const text = node.textContent.trim();
                if (text) cells.push(text);
            });
        }

        return cells;
    }

    getTextNodes(element) {
        const textNodes = [];
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        let node;
        while (node = walker.nextNode()) {
            if (node.textContent.trim()) {
                textNodes.push(node);
            }
        }

        return textNodes;
    }

    looksLikeHeader(element) {
        const style = window.getComputedStyle(element);
        const fontWeight = parseInt(style.fontWeight) || 400;
        const fontSize = parseFloat(style.fontSize) || 14;
        const backgroundColor = style.backgroundColor;
        
        return fontWeight >= 600 || fontSize > 16 || 
               backgroundColor !== 'rgba(0, 0, 0, 0)';
    }

    inferColumnTypes(rows) {
        if (rows.length === 0) return [];
        
        const columnCount = Math.max(...rows.map(row => row.length));
        const types = [];

        for (let col = 0; col < columnCount; col++) {
            const values = rows.map(row => row[col] || '').filter(val => val.length > 0);
            types.push(this.inferColumnType(values));
        }

        return types;
    }

    inferColumnType(values) {
        if (values.length === 0) return 'text';

        const patterns = {
            number: /^-?\d+(\.\d+)?$/,
            currency: /^[\$\€\£\¥]?\s?\d+([,\.]?\d+)*(\.\d{2})?$/,
            date: /^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$|^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
            email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            url: /^https?:\/\/.+/,
            phone: /^[\+]?[\d\s\-\(\)]+$/
        };

        for (const [type, pattern] of Object.entries(patterns)) {
            const matches = values.filter(val => pattern.test(val.trim())).length;
            if (matches / values.length > 0.7) {
                return type;
            }
        }

        return 'text';
    }

    generatePreview(tableData) {
        const maxRows = 3;
        const maxCols = 4;
        
        let preview = '';
        if (tableData.headers.length > 0) {
            preview += tableData.headers.slice(0, maxCols).join(' | ') + '\n';
            preview += '─'.repeat(Math.min(50, preview.length - 1)) + '\n';
        }
        
        tableData.rows.slice(0, maxRows).forEach(row => {
            preview += row.slice(0, maxCols).map(cell => 
                cell.length > 20 ? cell.substring(0, 17) + '...' : cell
            ).join(' | ') + '\n';
        });

        if (tableData.rows.length > maxRows) {
            preview += `... and ${tableData.rows.length - maxRows} more rows\n`;
        }

        return preview;
    }

    getElementSelector(element) {
        if (element.id) return `#${element.id}`;
        
        const path = [];
        while (element && element.nodeType === Node.ELEMENT_NODE) {
            let selector = element.nodeName.toLowerCase();
            if (element.className) {
                selector += '.' + element.className.trim().split(/\s+/).join('.');
            }
            path.unshift(selector);
            element = element.parentNode;
            if (path.length > 5) break;
        }
        
        return path.join(' > ');
    }

    updateUI() {
        document.getElementById('status').style.display = 'none';
        document.getElementById('content').style.display = 'block';
        document.getElementById('tableCount').textContent = this.detectedTables.length;

        const tableList = document.getElementById('tableList');
        tableList.innerHTML = '';

        if (this.detectedTables.length === 0) {
            tableList.innerHTML = `
                <div class="no-tables">
                    <h4>No tables detected</h4>
                    <p>Try using "Deep Scan" or "Manual Selection" to find hidden tabular data.</p>
                </div>
            `;
            return;
        }

        this.detectedTables.forEach(table => {
            const item = this.createTableItem(table);
            tableList.appendChild(item);
        });
    }

    createTableItem(table) {
        const item = document.createElement('div');
        item.className = 'table-item';
        item.dataset.tableId = table.id;

        const confidenceClass = table.confidence >= 0.8 ? 'high' : 
                               table.confidence >= 0.6 ? 'medium' : 'low';

        item.innerHTML = `
            <div class="table-info">
                <span class="table-title">${table.type === 'explicit' ? 'HTML Table' : 'Implicit Table'} #${table.id}</span>
                <span class="confidence-score ${confidenceClass}">${Math.round(table.confidence * 100)}%</span>
            </div>
            <div class="table-preview-text">${table.preview}</div>
        `;

        item.addEventListener('click', () => this.viewTable(table));
        item.addEventListener('mouseenter', () => this.highlightTable(table));
        item.addEventListener('mouseleave', () => this.unhighlightTable(table));

        return item;
    }

    async highlightTable(table) {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        
        chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: (selector) => {
                const element = document.querySelector(selector);
                if (element) {
                    element.style.outline = '3px solid #667eea';
                    element.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                }
            },
            args: [table.element]
        });
    }

    async unhighlightTable(table) {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        
        chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: (selector) => {
                const element = document.querySelector(selector);
                if (element) {
                    element.style.outline = '';
                    element.style.backgroundColor = '';
                }
            },
            args: [table.element]
        });
    }

    viewTable(table) {
        this.currentTable = table;
        this.renderTablePreview(table);
        document.getElementById('content').style.display = 'none';
        document.getElementById('tablePreview').style.display = 'block';
    }

    renderTablePreview(table) {
        const container = document.getElementById('tableContainer');
        const tableElement = document.createElement('table');
        tableElement.className = 'preview-table';

        if (table.data.headers.length > 0) {
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            table.data.headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            tableElement.appendChild(thead);
        }

        const tbody = document.createElement('tbody');
        table.data.rows.forEach(row => {
            const tr = document.createElement('tr');
            row.forEach(cell => {
                const td = document.createElement('td');
                td.textContent = cell;
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });

        tableElement.appendChild(tbody);
        container.innerHTML = '';
        container.appendChild(tableElement);
    }

    showMainView() {
        document.getElementById('tablePreview').style.display = 'none';
        document.getElementById('content').style.display = 'block';
    }

    exportData(format) {
        if (!this.currentTable) return;

        const data = this.currentTable.data;
        let content = '';
        let filename = `table_${this.currentTable.id}.${format}`;

        if (format === 'csv') {
            content = this.convertToCSV(data);
        } else if (format === 'json') {
            content = this.convertToJSON(data);
        }

        this.downloadFile(content, filename);
    }

    convertToCSV(data) {
        const rows = [];
        
        if (data.headers.length > 0) {
            rows.push(data.headers.map(header => this.escapeCSV(header)).join(','));
        }
        
        data.rows.forEach(row => {
            rows.push(row.map(cell => this.escapeCSV(cell)).join(','));
        });

        return rows.join('\n');
    }

    escapeCSV(field) {
        if (field.includes(',') || field.includes('"') || field.includes('\n')) {
            return `"${field.replace(/"/g, '""')}"`;
        }
        return field;
    }

    convertToJSON(data) {
        const result = [];
        
        data.rows.forEach(row => {
            const obj = {};
            row.forEach((cell, index) => {
                const key = data.headers[index] || `column_${index + 1}`;
                obj[key] = cell;
            });
            result.push(obj);
        });

        return JSON.stringify(result, null, 2);
    }

    downloadFile(content, filename) {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async performDeepScan() {
        document.getElementById('status').style.display = 'block';
        document.getElementById('content').style.display = 'none';
        document.querySelector('#status span').textContent = 'Performing deep scan...';

        setTimeout(async () => {
            await this.scanCurrentPage();
        }, 1000);
    }

    activateManualSelection() {
        window.close();
    }

    startMultiPageExtraction() {
        alert('Multi-page extraction feature coming soon!');
    }

    showError(message) {
        document.getElementById('status').innerHTML = `
            <div style="color: #dc3545;">
                <strong>Error:</strong> ${message}
            </div>
        `;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CognitoTablePopup();
});

4. Uncaught (in promise) TypeError: Cannot set properties of null (setting 'textContent')

Context
popup.html
Stack Trace

class CognitoTablePopup {
    constructor() {
        this.detectedTables = [];
        this.currentTable = null;
        this.init();
    }

    async init() {
        await this.setupEventListeners();
        await this.scanCurrentPage();
    }

    setupEventListeners() {
        document.getElementById('deepScan').addEventListener('click', () => this.performDeepScan());
        document.getElementById('manualSelect').addEventListener('click', () => this.activateManualSelection());
        document.getElementById('multiPage').addEventListener('click', () => this.startMultiPageExtraction());
        document.getElementById('backBtn').addEventListener('click', () => this.showMainView());
        document.getElementById('exportCsv').addEventListener('click', () => this.exportData('csv'));
        document.getElementById('exportJson').addEventListener('click', () => this.exportData('json'));
    }

    async scanCurrentPage() {
        try {
            const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
            
            const results = await chrome.scripting.executeScript({
                target: { tabId: tab.id },
                func: this.scanPageForTables
            });

            const tables = results[0].result;
            this.detectedTables = tables;
            this.updateUI();
        } catch (error) {
            console.error('Error scanning page:', error);
            this.showError('Failed to scan page for tables');
        }
    }

    scanPageForTables() {
        const tables = [];
        let tableId = 0;

        const explicitTables = document.querySelectorAll('table');
        explicitTables.forEach(table => {
            const tableData = this.extractTableData(table, 'explicit');
            if (tableData.rows.length > 0) {
                tables.push({
                    id: ++tableId,
                    type: 'explicit',
                    confidence: 0.95,
                    element: this.getElementSelector(table),
                    data: tableData,
                    preview: this.generatePreview(tableData)
                });
            }
        });

        const implicitTables = this.findImplicitTables();
        implicitTables.forEach(table => {
            const tableData = this.extractTableData(table.element, 'implicit');
            if (tableData.rows.length > 1) {
                tables.push({
                    id: ++tableId,
                    type: 'implicit',
                    confidence: table.confidence,
                    element: this.getElementSelector(table.element),
                    data: tableData,
                    preview: this.generatePreview(tableData)
                });
            }
        });

        return tables;
    }

    findImplicitTables() {
        const candidates = [];
        const containers = document.querySelectorAll('div, ul, ol, section, article');
        
        containers.forEach(container => {
            const children = Array.from(container.children);
            if (children.length < 2) return;

            const structuralSimilarity = this.calculateStructuralSimilarity(children);
            if (structuralSimilarity > 0.7) {
                const visualAlignment = this.assessVisualAlignment(children);
                const confidence = (structuralSimilarity + visualAlignment) / 2;
                
                if (confidence > 0.6) {
                    candidates.push({
                        element: container,
                        confidence: confidence,
                        children: children
                    });
                }
            }
        });

        return candidates.sort((a, b) => b.confidence - a.confidence).slice(0, 5);
    }

    calculateStructuralSimilarity(elements) {
        if (elements.length < 2) return 0;

        const signatures = elements.map(el => this.getStructuralSignature(el));
        const uniqueSignatures = new Set(signatures);
        
        return 1 - (uniqueSignatures.size - 1) / (signatures.length - 1);
    }

    getStructuralSignature(element) {
        const tagName = element.tagName.toLowerCase();
        const childCount = element.children.length;
        const classNames = Array.from(element.classList).sort().join(' ');
        const hasText = element.textContent.trim().length > 0;
        
        return `${tagName}:${childCount}:${classNames}:${hasText}`;
    }

    assessVisualAlignment(elements) {
        const rects = elements.map(el => el.getBoundingClientRect());
        
        const leftAlignment = this.calculateAlignment(rects.map(r => r.left));
        const widthConsistency = this.calculateAlignment(rects.map(r => r.width));
        const heightConsistency = this.calculateAlignment(rects.map(r => r.height));
        
        return (leftAlignment + widthConsistency + heightConsistency) / 3;
    }

    calculateAlignment(values) {
        if (values.length < 2) return 1;
        
        const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
        const variance = values.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / values.length;
        const stdDev = Math.sqrt(variance);
        
        return Math.max(0, 1 - (stdDev / avg));
    }

    extractTableData(element, type) {
        const data = { headers: [], rows: [], columnTypes: [] };

        if (type === 'explicit' && element.tagName.toLowerCase() === 'table') {
            return this.extractExplicitTableData(element);
        } else {
            return this.extractImplicitTableData(element);
        }
    }

    extractExplicitTableData(table) {
        const data = { headers: [], rows: [], columnTypes: [] };
        const headerRow = table.querySelector('thead tr, tr:first-child');
        const bodyRows = table.querySelectorAll('tbody tr, tr:not(:first-child)');

        if (headerRow) {
            const headers = Array.from(headerRow.querySelectorAll('th, td')).map(cell => 
                cell.textContent.trim()
            );
            data.headers = headers;
        }

        bodyRows.forEach(row => {
            const cells = Array.from(row.querySelectorAll('td, th')).map(cell => 
                cell.textContent.trim()
            );
            if (cells.some(cell => cell.length > 0)) {
                data.rows.push(cells);
            }
        });

        data.columnTypes = this.inferColumnTypes(data.rows);
        return data;
    }

    extractImplicitTableData(container) {
        const data = { headers: [], rows: [], columnTypes: [] };
        const children = Array.from(container.children);

        children.forEach((child, index) => {
            const cells = this.extractCellsFromElement(child);
            if (cells.length > 0) {
                if (index === 0 && this.looksLikeHeader(child)) {
                    data.headers = cells;
                } else {
                    data.rows.push(cells);
                }
            }
        });

        if (data.headers.length === 0 && data.rows.length > 0) {
            data.headers = data.rows[0].map((_, i) => `Column ${i + 1}`);
        }

        data.columnTypes = this.inferColumnTypes(data.rows);
        return data;
    }

    extractCellsFromElement(element) {
        const cells = [];
        const textNodes = this.getTextNodes(element);
        
        if (textNodes.length === 0) {
            const text = element.textContent.trim();
            if (text) cells.push(text);
        } else {
            textNodes.forEach(node => {
                const text = node.textContent.trim();
                if (text) cells.push(text);
            });
        }

        return cells;
    }

    getTextNodes(element) {
        const textNodes = [];
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        let node;
        while (node = walker.nextNode()) {
            if (node.textContent.trim()) {
                textNodes.push(node);
            }
        }

        return textNodes;
    }

    looksLikeHeader(element) {
        const style = window.getComputedStyle(element);
        const fontWeight = parseInt(style.fontWeight) || 400;
        const fontSize = parseFloat(style.fontSize) || 14;
        const backgroundColor = style.backgroundColor;
        
        return fontWeight >= 600 || fontSize > 16 || 
               backgroundColor !== 'rgba(0, 0, 0, 0)';
    }

    inferColumnTypes(rows) {
        if (rows.length === 0) return [];
        
        const columnCount = Math.max(...rows.map(row => row.length));
        const types = [];

        for (let col = 0; col < columnCount; col++) {
            const values = rows.map(row => row[col] || '').filter(val => val.length > 0);
            types.push(this.inferColumnType(values));
        }

        return types;
    }

    inferColumnType(values) {
        if (values.length === 0) return 'text';

        const patterns = {
            number: /^-?\d+(\.\d+)?$/,
            currency: /^[\$\€\£\¥]?\s?\d+([,\.]?\d+)*(\.\d{2})?$/,
            date: /^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$|^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
            email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            url: /^https?:\/\/.+/,
            phone: /^[\+]?[\d\s\-\(\)]+$/
        };

        for (const [type, pattern] of Object.entries(patterns)) {
            const matches = values.filter(val => pattern.test(val.trim())).length;
            if (matches / values.length > 0.7) {
                return type;
            }
        }

        return 'text';
    }

    generatePreview(tableData) {
        const maxRows = 3;
        const maxCols = 4;
        
        let preview = '';
        if (tableData.headers.length > 0) {
            preview += tableData.headers.slice(0, maxCols).join(' | ') + '\n';
            preview += '─'.repeat(Math.min(50, preview.length - 1)) + '\n';
        }
        
        tableData.rows.slice(0, maxRows).forEach(row => {
            preview += row.slice(0, maxCols).map(cell => 
                cell.length > 20 ? cell.substring(0, 17) + '...' : cell
            ).join(' | ') + '\n';
        });

        if (tableData.rows.length > maxRows) {
            preview += `... and ${tableData.rows.length - maxRows} more rows\n`;
        }

        return preview;
    }

    getElementSelector(element) {
        if (element.id) return `#${element.id}`;
        
        const path = [];
        while (element && element.nodeType === Node.ELEMENT_NODE) {
            let selector = element.nodeName.toLowerCase();
            if (element.className) {
                selector += '.' + element.className.trim().split(/\s+/).join('.');
            }
            path.unshift(selector);
            element = element.parentNode;
            if (path.length > 5) break;
        }
        
        return path.join(' > ');
    }

    updateUI() {
        document.getElementById('status').style.display = 'none';
        document.getElementById('content').style.display = 'block';
        document.getElementById('tableCount').textContent = this.detectedTables.length;

        const tableList = document.getElementById('tableList');
        tableList.innerHTML = '';

        if (this.detectedTables.length === 0) {
            tableList.innerHTML = `
                <div class="no-tables">
                    <h4>No tables detected</h4>
                    <p>Try using "Deep Scan" or "Manual Selection" to find hidden tabular data.</p>
                </div>
            `;
            return;
        }

        this.detectedTables.forEach(table => {
            const item = this.createTableItem(table);
            tableList.appendChild(item);
        });
    }

    createTableItem(table) {
        const item = document.createElement('div');
        item.className = 'table-item';
        item.dataset.tableId = table.id;

        const confidenceClass = table.confidence >= 0.8 ? 'high' : 
                               table.confidence >= 0.6 ? 'medium' : 'low';

        item.innerHTML = `
            <div class="table-info">
                <span class="table-title">${table.type === 'explicit' ? 'HTML Table' : 'Implicit Table'} #${table.id}</span>
                <span class="confidence-score ${confidenceClass}">${Math.round(table.confidence * 100)}%</span>
            </div>
            <div class="table-preview-text">${table.preview}</div>
        `;

        item.addEventListener('click', () => this.viewTable(table));
        item.addEventListener('mouseenter', () => this.highlightTable(table));
        item.addEventListener('mouseleave', () => this.unhighlightTable(table));

        return item;
    }

    async highlightTable(table) {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        
        chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: (selector) => {
                const element = document.querySelector(selector);
                if (element) {
                    element.style.outline = '3px solid #667eea';
                    element.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                }
            },
            args: [table.element]
        });
    }

    async unhighlightTable(table) {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        
        chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: (selector) => {
                const element = document.querySelector(selector);
                if (element) {
                    element.style.outline = '';
                    element.style.backgroundColor = '';
                }
            },
            args: [table.element]
        });
    }

    viewTable(table) {
        this.currentTable = table;
        this.renderTablePreview(table);
        document.getElementById('content').style.display = 'none';
        document.getElementById('tablePreview').style.display = 'block';
    }

    renderTablePreview(table) {
        const container = document.getElementById('tableContainer');
        const tableElement = document.createElement('table');
        tableElement.className = 'preview-table';

        if (table.data.headers.length > 0) {
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            table.data.headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            tableElement.appendChild(thead);
        }

        const tbody = document.createElement('tbody');
        table.data.rows.forEach(row => {
            const tr = document.createElement('tr');
            row.forEach(cell => {
                const td = document.createElement('td');
                td.textContent = cell;
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });

        tableElement.appendChild(tbody);
        container.innerHTML = '';
        container.appendChild(tableElement);
    }

    showMainView() {
        document.getElementById('tablePreview').style.display = 'none';
        document.getElementById('content').style.display = 'block';
    }

    exportData(format) {
        if (!this.currentTable) return;

        const data = this.currentTable.data;
        let content = '';
        let filename = `table_${this.currentTable.id}.${format}`;

        if (format === 'csv') {
            content = this.convertToCSV(data);
        } else if (format === 'json') {
            content = this.convertToJSON(data);
        }

        this.downloadFile(content, filename);
    }

    convertToCSV(data) {
        const rows = [];
        
        if (data.headers.length > 0) {
            rows.push(data.headers.map(header => this.escapeCSV(header)).join(','));
        }
        
        data.rows.forEach(row => {
            rows.push(row.map(cell => this.escapeCSV(cell)).join(','));
        });

        return rows.join('\n');
    }

    escapeCSV(field) {
        if (field.includes(',') || field.includes('"') || field.includes('\n')) {
            return `"${field.replace(/"/g, '""')}"`;
        }
        return field;
    }

    convertToJSON(data) {
        const result = [];
        
        data.rows.forEach(row => {
            const obj = {};
            row.forEach((cell, index) => {
                const key = data.headers[index] || `column_${index + 1}`;
                obj[key] = cell;
            });
            result.push(obj);
        });

        return JSON.stringify(result, null, 2);
    }

    downloadFile(content, filename) {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async performDeepScan() {
        document.getElementById('status').style.display = 'block';
        document.getElementById('content').style.display = 'none';
        document.querySelector('#status span').textContent = 'Performing deep scan...';

        setTimeout(async () => {
            await this.scanCurrentPage();
        }, 1000);
    }

    activateManualSelection() {
        window.close();
    }

    startMultiPageExtraction() {
        alert('Multi-page extraction feature coming soon!');
    }

    showError(message) {
        document.getElementById('status').innerHTML = `
            <div style="color: #dc3545;">
                <strong>Error:</strong> ${message}
            </div>
        `;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CognitoTablePopup();
});